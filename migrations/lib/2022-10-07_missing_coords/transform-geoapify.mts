import axios from 'axios';
import original from './input_2.json' assert { type: 'json' }
// import original from './input_test.json' assert { type: 'json' }
import fs from 'fs';
import PQueue from 'p-queue';
import MockAdapter from 'axios-mock-adapter';
import mockResults from './test.json' assert { type: 'json' }
import dotenv from 'dotenv'

dotenv.config({path: '../../../.env'})



export const url = 'https://api.geoapify.com/v1/geocode/search';
const apiKey = process.env.GEOAPIFY_KEY 



/* API testing - don't want to use those precious free credits */

// const randDelay = Math.floor(Math.random() * 2750);

// const randomResult = () => {
// 	const length = mockResults.length;
// 	const randIdx = Math.floor(Math.random() * length);
// 	return mockResults[randIdx];
// };

// const mock = new MockAdapter(axios, {delayResponse: randDelay});
// mock.onGet(url).reply((config) => {
// 	const res = randomResult()
// 	return [200, res]
// });

/* End of test stuff */

export const origData: OrgData[] = original;
const rawOutput: ApiResult[] = [];
const errorOut: unknown[] = []

/* Set up queue for rate limiting - API provider allows max of 5 requests/second */

const queue = new PQueue({
	concurrency: 1,
	intervalCap: 1,
	interval: 400,
	autoStart: false,
	carryoverConcurrencyCount: true
});
let qtotal = 0;
let qcount = 0;
let qerror = 0
let qtimer: number
queue.on('add', () => {
	console.info(` 🛠   Added item #${++qtotal}.`);
});
queue.on('active', () => {
	qtimer = Date.now()
	console.info(
		`<-- Working on item #${++qcount} of ${qtotal}. Remaining: ${queue.size}. Pending: ${
			queue.pending
		}. Errors: ${qerror}.`
	);
});
queue.on('completed',()=>{
	console.info(`--> Job finished in ${Date.now() - qtimer}ms`)
})
queue.on('error', (error) => {

	console.error(error)
});

queue.on('idle', () =>
	{
		console.info(`<==> Writing data to file.`)
		fs.writeFileSync('./out.json', JSON.stringify(outData, null, 2))
		if (errorOut.length) {
			fs.writeFileSync('./errors.json', JSON.stringify(errorOut, null, 2))
		}
		console.info(`🏁 🏁 Work queue finished! 🏁 🏁`)
	}
);


const outData: OrgData[] = [];

/**
 * It takes an entry from the input data, and returns a new entry with the same data, but with latitude
 * and longitude coordinates
 * @param {OrgData} entry - OrgData - this is the entry from the input data that we're currently
 * processing
 * @param {number} i - the index of the current entry in the array
 */
export const getCoords = async (entry: OrgData, i: number) => {
	try {
		console.log(`    Organization: ${entry.name}`);
		const {address, city, state, zip_code, country} = entry ?? {
			address: undefined,
			city: undefined,
			state: undefined,
			zip_code: undefined,
			country: undefined
		};
		const query = [address, city, state, zip_code, country].join();

		const {data} = await axios.get<ApiResult>(url, {
			params: {
				text: query,
				apiKey: apiKey,
				format: 'json'
			}
		});
		rawOutput.push(data);
		console.log(
			`    Coordinate data: ${data.results[0].lat}, ${data.results[0].lon}`
		);
		outData.push({
			...entry,
			lat: data.results[0].lat.toString(),
			long: data.results[0].lon.toString()
		});
	} catch (err) {
		qerror++
		errorOut.push(err)
		console.error(err);
	}
};

origData.forEach((entry, i) => queue.add(() => getCoords(entry, i)));




queue.start()
// export const outputData = origData.map( async ( entry, i ) => await getCoords(entry,i) )



interface ApiResult {
	results: ResultElement[];
	query: Query;
}

interface Query {
	text: string;
	parsed: Parsed;
}

interface Parsed {
	housenumber: string;
	street: string;
	postcode: string;
	city: string;
	state: string;
	country: string;
	expected_type: string;
}

interface ResultElement {
	country_code: string;
	country: string;
	county?: string;
	datasource: Datasource;
	state?: string;
	city: string;
	lon: number;
	lat: number;
	state_code?: string;
	formatted: string;
	address_line1: string;
	address_line2: string;
	timezone: Timezone;
	result_type: string;
	rank: Rank;
	place_id: string;
	bbox: Bbox;
}

interface Bbox {
	lon1: number;
	lat1: number;
	lon2: number;
	lat2: number;
}

interface Datasource {
	sourcename: string;
	url: string;
}

interface Rank {
	popularity: number;
	confidence: number;
	confidence_city_level: number;
	match_type: string;
}

interface Timezone {
	name: string;
	offset_STD: string;
	offset_STD_seconds: number;
	offset_DST: string;
	offset_DST_seconds: number;
	abbreviation_STD: string;
	abbreviation_DST: string;
}

// Generated by https://quicktype.io

interface OrgData {
	_id: ID;
	name: string;
	loc_id: ID;
	address?: string;
	city?: string;
	state?: string;
	zip_code?: string;
	country?: string;
	show_on_organization?: boolean;
	unit?: string;
	lat?: string | null;
	long?: string | null;
}

interface ID {
	$oid: string;
}
